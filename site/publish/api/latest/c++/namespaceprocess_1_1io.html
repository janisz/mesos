<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>Apache Mesos: process::io Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Apache Mesos
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceprocess.html">process</a></li><li class="navelem"><a class="el" href="namespaceprocess_1_1io.html">io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">process::io Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a311cf1bd4da1698b447e05f57dcab78d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; short &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#a311cf1bd4da1698b447e05f57dcab78d">poll</a> (int fd, short events)</td></tr>
<tr class="memdesc:a311cf1bd4da1698b447e05f57dcab78d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the events (a subset of the events specified) that can be performed on the specified file descriptor without blocking.  <a href="#a311cf1bd4da1698b447e05f57dcab78d">More...</a><br/></td></tr>
<tr class="separator:a311cf1bd4da1698b447e05f57dcab78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38a1c7e4ee89d3f37eb69a7d26047a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#af38a1c7e4ee89d3f37eb69a7d26047a2">read</a> (int fd, void *data, size_t size)</td></tr>
<tr class="memdesc:af38a1c7e4ee89d3f37eb69a7d26047a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a single non-blocking read by polling on the specified file descriptor until any data can be be read.  <a href="#af38a1c7e4ee89d3f37eb69a7d26047a2">More...</a><br/></td></tr>
<tr class="separator:af38a1c7e4ee89d3f37eb69a7d26047a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94adeba995737f0b1bb4ae123cadbf69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#a94adeba995737f0b1bb4ae123cadbf69">read</a> (int fd)</td></tr>
<tr class="memdesc:a94adeba995737f0b1bb4ae123cadbf69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a series of asynchronous reads, until EOF is reached.  <a href="#a94adeba995737f0b1bb4ae123cadbf69">More...</a><br/></td></tr>
<tr class="separator:a94adeba995737f0b1bb4ae123cadbf69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075e8e774e133a8f513d60e8afd3e05a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#a075e8e774e133a8f513d60e8afd3e05a">write</a> (int fd, const void *data, size_t size)</td></tr>
<tr class="memdesc:a075e8e774e133a8f513d60e8afd3e05a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a single non-blocking write by polling on the specified file descriptor until data can be be written.  <a href="#a075e8e774e133a8f513d60e8afd3e05a">More...</a><br/></td></tr>
<tr class="separator:a075e8e774e133a8f513d60e8afd3e05a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9f58c5f9fac5fc2c9c9477d38def24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structNothing.html">Nothing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#a9e9f58c5f9fac5fc2c9c9477d38def24">write</a> (int fd, const std::string &amp;data)</td></tr>
<tr class="memdesc:a9e9f58c5f9fac5fc2c9c9477d38def24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a series of asynchronous writes, until all of data has been written.  <a href="#a9e9f58c5f9fac5fc2c9c9477d38def24">More...</a><br/></td></tr>
<tr class="separator:a9e9f58c5f9fac5fc2c9c9477d38def24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a3b5657cb48dc39f79b9ee4535d1ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; <a class="el" href="structNothing.html">Nothing</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#ab4a3b5657cb48dc39f79b9ee4535d1ff">redirect</a> (int from, <a class="el" href="classOption.html">Option</a>&lt; int &gt; to, size_t chunk=4096)</td></tr>
<tr class="memdesc:ab4a3b5657cb48dc39f79b9ee4535d1ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redirect output from the 'from' file descriptor to the 'to' file descriptor (or /dev/null if 'to' is <a class="el" href="structNone.html">None</a>).  <a href="#ab4a3b5657cb48dc39f79b9ee4535d1ff">More...</a><br/></td></tr>
<tr class="separator:ab4a3b5657cb48dc39f79b9ee4535d1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c988d2bd504c17887c19531ed8dc4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#a75c988d2bd504c17887c19531ed8dc4c">peek</a> (int fd, void *data, size_t size, size_t limit)</td></tr>
<tr class="memdesc:a75c988d2bd504c17887c19531ed8dc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a single non-blocking peek by polling on the specified file descriptor until any data can be be peeked.  <a href="#a75c988d2bd504c17887c19531ed8dc4c">More...</a><br/></td></tr>
<tr class="separator:a75c988d2bd504c17887c19531ed8dc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4e23e69444c0f041fd810fecfd1a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#a3f4e23e69444c0f041fd810fecfd1a44">peek</a> (int fd, size_t limit)</td></tr>
<tr class="memdesc:a3f4e23e69444c0f041fd810fecfd1a44"><td class="mdescLeft">&#160;</td><td class="mdescRight">A more convenient version of <a class="el" href="namespaceprocess_1_1io.html#a75c988d2bd504c17887c19531ed8dc4c" title="Performs a single non-blocking peek by polling on the specified file descriptor until any data can be...">io::peek</a> that does not require allocating the buffer.  <a href="#a3f4e23e69444c0f041fd810fecfd1a44">More...</a><br/></td></tr>
<tr class="separator:a3f4e23e69444c0f041fd810fecfd1a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aca1f059ca9f0d7360631c621debeb879"><td class="memItemLeft" align="right" valign="top">const short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#aca1f059ca9f0d7360631c621debeb879">READ</a> = 0x01</td></tr>
<tr class="memdesc:aca1f059ca9f0d7360631c621debeb879"><td class="mdescLeft">&#160;</td><td class="mdescRight">A possible event while polling.  <a href="#aca1f059ca9f0d7360631c621debeb879">More...</a><br/></td></tr>
<tr class="separator:aca1f059ca9f0d7360631c621debeb879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab005316d71b45c5b05de0a6234c6f8fc"><td class="memItemLeft" align="right" valign="top">const short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#ab005316d71b45c5b05de0a6234c6f8fc">WRITE</a> = 0x02</td></tr>
<tr class="memdesc:ab005316d71b45c5b05de0a6234c6f8fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">A possible event while polling.  <a href="#ab005316d71b45c5b05de0a6234c6f8fc">More...</a><br/></td></tr>
<tr class="separator:ab005316d71b45c5b05de0a6234c6f8fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d62916736c1dfebd1585cf51f19d0c"><td class="memItemLeft" align="right" valign="top">const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceprocess_1_1io.html#a34d62916736c1dfebd1585cf51f19d0c">BUFFERED_READ_SIZE</a> = 16*4096</td></tr>
<tr class="memdesc:a34d62916736c1dfebd1585cf51f19d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffered read chunk size.  <a href="#a34d62916736c1dfebd1585cf51f19d0c">More...</a><br/></td></tr>
<tr class="separator:a34d62916736c1dfebd1585cf51f19d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a75c988d2bd504c17887c19531ed8dc4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;size_t&gt; process::io::peek </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a single non-blocking peek by polling on the specified file descriptor until any data can be be peeked. </p>
<p>The future will become ready when some data is peeked (may be less than specified by the limit). A failure will be returned if an error is detected. If end-of-file is reached, value zero will be returned.</p>
<p><b>NOTE</b>: This function is inspired by the MSG_PEEK flag of recv() in that it does not remove the peeked data from the queue. Thus, a subsequent <a class="el" href="namespaceprocess_1_1io.html#af38a1c7e4ee89d3f37eb69a7d26047a2" title="Performs a single non-blocking read by polling on the specified file descriptor until any data can be...">io::read</a> or <a class="el" href="namespaceprocess_1_1io.html#a75c988d2bd504c17887c19531ed8dc4c" title="Performs a single non-blocking peek by polling on the specified file descriptor until any data can be...">io::peek()</a> call will return the same data.</p>
<p>TODO(hartem): This function will currently return an error if fd is not a socket descriptor. Chnages need to be made to support ordinary files and pipes as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>socket descriptor. </td></tr>
    <tr><td class="paramname">data</td><td>buffer to which peek'd bytes will be copied. </td></tr>
    <tr><td class="paramname">size</td><td>size of the buffer. </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of bytes to peek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes peeked. A failure will be returned if an error is detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f4e23e69444c0f041fd810fecfd1a44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;std::string&gt; process::io::peek </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A more convenient version of <a class="el" href="namespaceprocess_1_1io.html#a75c988d2bd504c17887c19531ed8dc4c" title="Performs a single non-blocking peek by polling on the specified file descriptor until any data can be...">io::peek</a> that does not require allocating the buffer. </p>
<p><b>NOTE</b>: this function treats the limit parameter merely as an upper bound for the size of the data to peek. It does not wait until the specified amount of bytes is peeked. It returns as soon as some amount of data becomes available. It can not concatenate data from subsequent peeks because MSG_PEEK has known limitations when it comes to spanning message boundaries.</p>
<p><b>NOTE</b>: this function will return an error if the limit is greater than the internal peek buffer size (64k as of writing this comment, <a class="el" href="namespaceprocess_1_1io.html#a34d62916736c1dfebd1585cf51f19d0c" title="Buffered read chunk size. ">io::BUFFERED_READ_SIZE</a>. The caller should use the overlaod of <a class="el" href="namespaceprocess_1_1io.html#a75c988d2bd504c17887c19531ed8dc4c" title="Performs a single non-blocking peek by polling on the specified file descriptor until any data can be...">io::peek</a> that allows to supply a bigger buffer. TODO(hartem): It will be possible to fix this once SO_PEEK_OFF (introduced in 3.4 kernels) becomes universally available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>socket descriptor. </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of bytes to peek. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Peeked bytes. A failure will be returned if an error is detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a311cf1bd4da1698b447e05f57dcab78d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;short&gt; process::io::poll </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the events (a subset of the events specified) that can be performed on the specified file descriptor without blocking. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceprocess_1_1io.html#aca1f059ca9f0d7360631c621debeb879" title="A possible event while polling. ">process::io::READ</a> </dd>
<dd>
<a class="el" href="namespaceprocess_1_1io.html#ab005316d71b45c5b05de0a6234c6f8fc" title="A possible event while polling. ">process::io::WRITE</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af38a1c7e4ee89d3f37eb69a7d26047a2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;size_t&gt; process::io::read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a single non-blocking read by polling on the specified file descriptor until any data can be be read. </p>
<p>The future will become ready when some data is read (may be less than the specified size).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read or zero on EOF. A failure will be returned if an error is detected. </dd></dl>

</div>
</div>
<a class="anchor" id="a94adeba995737f0b1bb4ae123cadbf69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;std::string&gt; process::io::read </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a series of asynchronous reads, until EOF is reached. </p>
<p><b>NOTE</b>: when using this, ensure the sender will close the connection so that EOF can be reached.</p>
<dl class="section return"><dt>Returns</dt><dd>The concatentated result of the reads. A failure will be returned if the file descriptor is bad, or if the file descriptor cannot be duplicated, set to close-on-exec, or made non-blocking. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4a3b5657cb48dc39f79b9ee4535d1ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;<a class="el" href="structNothing.html">Nothing</a>&gt; process::io::redirect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classOption.html">Option</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chunk</em> = <code>4096</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Redirect output from the 'from' file descriptor to the 'to' file descriptor (or /dev/null if 'to' is <a class="el" href="structNone.html">None</a>). </p>
<p>The 'to' and 'from' file descriptors will be duplicated so that the file descriptors' lifetimes can be controlled within this function.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structNothing.html">Nothing</a> after EOF has been encountered on 'from' or if a failure has occurred. A failure will be returned if the file descriptor is bad, or if the file descriptor cannot be duplicated, set to close-on-exec, or made non-blocking. </dd></dl>

</div>
</div>
<a class="anchor" id="a075e8e774e133a8f513d60e8afd3e05a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;size_t&gt; process::io::write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a single non-blocking write by polling on the specified file descriptor until data can be be written. </p>
<p>The future will become ready when some data is written (may be less than the specified size of the data).</p>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. A failure will be returned if an error is detected. If writing to a socket or pipe, an error will be returned if the the read end of the socket or pipe has been closed. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e9f58c5f9fac5fc2c9c9477d38def24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classprocess_1_1Future.html">Future</a>&lt;<a class="el" href="structNothing.html">Nothing</a>&gt; process::io::write </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs a series of asynchronous writes, until all of data has been written. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structNothing.html">Nothing</a> or a failure if an error occurred. A failure will be returned if the file descriptor is bad, or if the file descriptor cannot be duplicated, set to close-on-exec, or made non-blocking. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a34d62916736c1dfebd1585cf51f19d0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const size_t process::io::BUFFERED_READ_SIZE = 16*4096</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Buffered read chunk size. </p>
<p>Roughly 16 pages. </p>

</div>
</div>
<a class="anchor" id="aca1f059ca9f0d7360631c621debeb879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const short process::io::READ = 0x01</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A possible event while polling. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceprocess_1_1io.html#a311cf1bd4da1698b447e05f57dcab78d" title="Returns the events (a subset of the events specified) that can be performed on the specified file des...">process::io::poll</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab005316d71b45c5b05de0a6234c6f8fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const short process::io::WRITE = 0x02</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A possible event while polling. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="namespaceprocess_1_1io.html#a311cf1bd4da1698b447e05f57dcab78d" title="Returns the events (a subset of the events specified) that can be performed on the specified file des...">process::io::poll</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
